<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Twitter on note.gosyujin.com - kk_Atakaの日記</title>
    <link>https://note.gosyujin.com/tags/twitter/</link>
    <description>Recent content in Twitter on note.gosyujin.com - kk_Atakaの日記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sun, 23 Jan 2011 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://note.gosyujin.com/tags/twitter/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RubyでTwitterにツイートをキメてみる</title>
      <link>https://note.gosyujin.com/2011/01/23/1295789180/</link>
      <pubDate>Sun, 23 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>https://note.gosyujin.com/2011/01/23/1295789180/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterにツイートをキメてみる 前回までのあらすじ  http://d.hatena.ne.jp/kk_Ataka/20101121/1290271210:title http://d.hatena.ne.jp/kk_Ataka/20101130/1291125511:title http://d.hatena.ne.jp/kk_Ataka/20101207/1291733295:title  ターミナルからOAuth認証をキメて、タイムラインを見られるようになりました。最後にターミナルからツイートが出来れば一応Twitterの見る・書くがライブラリ無しでできたことになります。
ツイートする方法  signatureを作成する。必要な値は以下のとおり。  oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version status New!   statusっていうのがツイートの本文ですね。signature作成するのにエスケープします。作成後のheaderはこんな感じ。[1]statusには「確認確認」って入ってます。
{ &amp;#34;oauth_nonce&amp;#34;=&amp;gt;&amp;#34;3c8293f9c5a0295148d428a26edb9f46&amp;#34;, &amp;#34;oauth_timestamp&amp;#34;=&amp;gt;&amp;#34;1295784908&amp;#34;, &amp;#34;oauth_signature_method&amp;#34;=&amp;gt;&amp;#34;HMAC-SHA1&amp;#34;, &amp;#34;oauth_consumer_key&amp;#34;=&amp;gt;&amp;#34;XXXXXXXXXXXXXXXXXXXXXX&amp;#34;, &amp;#34;oauth_token&amp;#34;=&amp;gt;&amp;#34;99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY&amp;#34;, &amp;#34;oauth_signature&amp;#34;=&amp;gt;&amp;#34;UKt1BmJ+UWNWrSmBuAyJ40iiCNY=&amp;#34;, &amp;#34;status&amp;#34;=&amp;gt;&amp;#34;%E7%A2%BA%E8%AA%8D%E7%A2%BA%E8%AA%8D&amp;#34;, &amp;#34;oauth_version&amp;#34;=&amp;gt;&amp;#34;1.0&amp;#34; } signature作成後  signatureを作成したら、headerからstatusを消します 残ったheaderをアルファベット順に並べ、xxx=yyy,vvv=zzz……の形で連結します。連結後はこんな感じ  oauth_consumer_key=XXXXXXXXXXXXXXXXXXXXXX,oauth_nonce=341d852d61cdc3c22e3e847b0ab69d20,oauth_signature=MR5WEJ1qHuE49ozgRYduNJ%2BBiCs%3D,oauth_signature_method=HMAC-SHA1,oauth_timestamp=1295785315,oauth_token=99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY,oauth_version=1.0  連結した上記の値をAuthorizationヘッダに入れる。入れた後はこんな感じ。  &amp;#34;Authorization&amp;#34;=&amp;gt;&amp;#34;OAuth oauth_consumer_key=XXXXXXXXXXXXXXXXXXXXXX,oauth_nonce=341d852d61cdc3c22e3e847b0ab69d20,oauth_signature=MR5WEJ1qHuE49ozgRYduNJ%2BBiCs%3D,oauth_signature_method=HMAC-SHA1,oauth_timestamp=1295785315,oauth_token=99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY,oauth_version=1.0&amp;#34;  Authorizationヘッダを作成したらhttp://api.twitter.com/1/statuses/home_timeline.jsonへPOST。また、ツイート本文を「status=本文」の形でくっつける  結果 以上で、Twitterにツイートが完了しました！　おっぱいきたーー
[f:id:kk_Ataka:20110123215838j:image]
ソース ソースはこんな感じです。
# -*- encoding: UTF-8 -*- require &amp;#39;openssl&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; require &amp;#39;nkf&amp;#39; require &amp;#39;time&amp;#39; # 署名 def sigunature(method, consumer_secret, oauth_token_secret, url, oauth_header=nil) # sigunature_keyの作成 # リクエストトークン時は&amp;#34;CONSUMER_SECRET&amp;amp;&amp;#34;(アンドが入っている) # アクセストークン時は&amp;#34;CONSUMER_SECRET&amp;amp;OAUTH_TOKEN_SECRET&amp;#34;として使用 sigunature_key = consumer_secret + &amp;#34;&amp;amp;&amp;#34; if !</description>
    </item>
    
    <item>
      <title>RubyでTwitterのタイムラインを取得してみる</title>
      <link>https://note.gosyujin.com/2010/12/07/1291733295/</link>
      <pubDate>Tue, 07 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>https://note.gosyujin.com/2010/12/07/1291733295/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのタイムラインを取得してみる 前回までのあらすじ  http://d.hatena.ne.jp/kk_Ataka/20101121/1290271210:title http://d.hatena.ne.jp/kk_Ataka/20101130/1291125511:title  前回までで、なんとかOAuth認証を突破する事ができました。目標は達成できたっちゃあできたんですが……せっかくなので、取得したアクセストークンを使ってTwitterからタイムラインを取得してみます！
タイムラインの取得方法  signatureを作成する 以下のパラメータをアルファベット順にxxx=yyy&amp;amp;vvv=zzz……の形で連結した値を[http://api.twitter.com/1/statuses/home_timeline.json]のおしりにくっつけてGET or POST  oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version   取得はこれで完了。
signatureの作成方法は今までと同じで、
 認証用の値を生成する(以下の3つの値を&amp;amp;で連結する)  &amp;ldquo;GET&amp;rdquo; &amp;ldquo;http://api.twitter.com/1/statuses/home_timeline.json&amp;ldquo;をエスケープしたもの oauth_signature以外のパラメータ[1]をアルファベット順に並べてxxx=yyy&amp;amp;vvv=zzz……の形で連結した値をエスケープしたもの  署名キーを生成する  &amp;ldquo;consumer_secret&amp;amp;oauth_token_secret&amp;rdquo;  キーを元に値をHMAC-SHA1方式で暗号化した値をbase64形式でエンコードする  です。OAuth認証して獲得したアクセストークン、oauth_tokenとoauth_token_secretを随所で使います。そして作成したsignatureと他のパラメータを[http://api.twitter.com/1/statuses/home_timeline.json]のおしりにくっつけて(今回は)GETリクエスト。
戻ってきたタイムライン タイムラインらしきものはjsonという形式のデータで戻って来ます。home_timeline.jsonのjson部分をxmlとかrssに変えるとxml形式のタイムライン、rss形式のタイムラインが返ってくるようですが今回はこのjsonを何とかしてみます。
jsonの詳細は後にググるとして、一人当たりの情報はこんな感じ。[2]
.......},{ \&amp;#34;coordinates\&amp;#34;:null, \&amp;#34;created_at\&amp;#34;:\&amp;#34;Tue Dec 07 13:50:49 +0000 2010\&amp;#34;, . (略) . \&amp;#34;in_reply_to_screen_name\&amp;#34;:null, \&amp;#34;in_reply_to_status_id_str\&amp;#34;:null, \&amp;#34;id_str\&amp;#34;:\&amp;#34;99999999999999999\&amp;#34;, \&amp;#34;contributors\&amp;#34;:null, \&amp;#34;retweet_count\&amp;#34;:null, \&amp;#34;in_reply_to_user_id\&amp;#34;:null, \&amp;#34;in_reply_to_user_id_str\&amp;#34;:null, \&amp;#34;user\&amp;#34;:{ . (略) . \&amp;#34;screen_name\&amp;#34;:\&amp;#34;kk_Ataka\&amp;#34;, \&amp;#34;profile_sidebar_border_color\&amp;#34;:\&amp;#34;C0DEED\&amp;#34;, \&amp;#34;follow_request_sent\&amp;#34;:false, \&amp;#34;location\&amp;#34;:\&amp;#34;Kawasaki, Kanagawa, Japan\&amp;#34;, .</description>
    </item>
    
    <item>
      <title>RubyでTwitterのOAuth認証をしてみる その2</title>
      <link>https://note.gosyujin.com/2010/11/30/1291125511/</link>
      <pubDate>Tue, 30 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://note.gosyujin.com/2010/11/30/1291125511/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのOAuth認証をしてみる その2 前回のエントリ では、リクエストトークンまで発行してもらえました。だもんで今回は前回に続いてアクセストークンを発行してもらいます。アクセストークン発行の流れとしては、
 今もらったリクエストトークンを付加して http://twitter.com/oauth/authorize へアクセスする 画面に表示されるPINコード(oauth_verifier)を控える リクエストトークンとPINコードをを付加して http://twitter.com/oauth/access_token へアクセスする  行きます。
PINコードを発行してもらう リクエストトークンを発行してもらうと、
oauth_token=XXXXXXXXXX&amp;amp;oauth_token_secret=YYYYYYYYYYYYYYYYYYYYYYYYYYYY&amp;amp;oauth_callback_confirmed=true という文字列がbodyに埋まってきたはず。[1]
この中から oauth_tokenを抜き出し、 http://twitter.com/oauth/authorize にパラメータとしてくっつけます。こんな感じ。
http://twitter.com/oauth/authorize?oauth_token=XXXXXXXXXX
アドレスが正しければ、以下のような画面が出るはず。[2]アプリケーションからのアクセスを許可しますか？　と尋ねられるので許可するを選択。
[f:id:kk_Ataka:20101130220734j:image]
許可すると、PINコードが画面に表示されるのでこれを控えておく。
[f:id:kk_Ataka:20101130220731j:image]
再度signatureを作成する このPINコードを&amp;rdquo;oauth_verify&amp;rdquo;として。先ほどURLに貼っつけたoauth_tokenを&amp;rdquo;oauth_token&amp;rdquo;としてパラメータとして持たせます。
そして、ここでもう一度signatureを作成を作成します。注意点としては、
 今まで使っていたoauth_signatureは一旦消して、以下のパラメータで新たにつくり直す  oauth_consumer_key oauth_nonce oauth_signature_method oauth_timestamp oauth_version oauth_token New! oauth_verifier New!  URLは&amp;rdquo;http://twitter.com/oauth/access_token&amp;rdquo;をエスケープしたもの 暗号化用のキーは&amp;rdquo;consumer_secret&amp;amp;oauth_token_secret&amp;rdquo;[3]  この3点でしょうか。
signatureが作成できたら、前回と同様にアルファベット順に並べて連結し、URLのおしりにくっつけます。URLはこんな感じになります。
[f:id:kk_Ataka:20101130223243j:image]
成功したら、oauth_token, oauth_token_secret, user_id, screen_nameが返ってきます。これ俺や！！
[f:id:kk_Ataka:20101130220728j:image]
ここで返してもらったoauth_tokenとoauth_token_secretは本物なので大切にとっておく！　というわけで、次は自分のTimelineを取得します！
ソースはこんな感じ。
require &amp;#39;openssl&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; # signature作成 def signature(method, consumer_secret, oauth_token_secret, url, oauth_header) # signature_keyの作成 # リクエストトークン時は&amp;#34;CONSUMER_SECRET&amp;amp;&amp;#34;(アンドが入っている) # アクセストークン時は&amp;#34;CONSUMER_SECRET&amp;amp;OAUTH_TOKEN_SECRET&amp;#34;として使用 signature_key = consumer_secret + &amp;#34;&amp;amp;&amp;#34; if !</description>
    </item>
    
    <item>
      <title>RubyでTwitterのOAuth認証をしてみる</title>
      <link>https://note.gosyujin.com/2010/11/21/1290271210/</link>
      <pubDate>Sun, 21 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://note.gosyujin.com/2010/11/21/1290271210/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのOAuth認証をしてみる 随分前にTwitterがベーシック認証からOAuth認証に切り替えたという事で。Java+Wicket+AppEngineでベーシック認証を駆使して作っていたTwitterサイトが見れなくなったもんで切り替えました。(http://gihyo.jp/dev/feature/01/wicket:title を見つつ)
一応出来たんですが、結局のところOAuthがどうなってるのかよくわからなかった……ので、ちょっと一から書いてみようと。
id:Yoshiori さんのhttp://d.hatena.ne.jp/Yoshiori/20100929/1285727199:title と、 id:yuroyoro さんの[http://d.hatena.ne.jp/yuroyoro/20100506/1273137673:title]がとっても詳しかったので、参考にしました。
大きな流れとしては、
 consumer_keyとconsumer_secretを発行してもらう リクエストトークンを発行してもらう アクセストークンを発行してもらう  の3項目。今回はリクエストトークンを発行してもらうところまでやります。
準備 Twitterにアプリを登録し、consumer_keyとconsumer_secretを発行してもらう  Twitterにログイン &amp;gt; 設定 &amp;gt; 連携アプリ を選択  [f:id:kk_Ataka:20101120225746p:image]
 開発者の方へ &amp;gt; こちら を選択  [f:id:kk_Ataka:20101120230042p:image]
 ページ下部の新しいアプリケーションを追加 を選択  [f:id:kk_Ataka:20101120230314p:image]
後で編集もできるのでとりあえず入力しておく。下記の2項目はとりあえず
 - アプリケーションの種類: クライアントアプリケーション  標準のアクセスタイプ: Read &amp;amp; Write   にしておく。
 登録したら、consumer_keyとconsumer_secretをもらえるので控えておく  [f:id:kk_Ataka:20101120232314p:image]
フォローをリクエストしました。のURL、Access token URL、Authorize URLは認証時に使うのでこれも控えておく。
リクエストトークンを発行してもらう こっからRuby。以下のパラメータを生成してhttp://twitter.com/oauth/request_tokenに送ります。POSTでもGETでもよいみたいなので、今回はGETを使ってURLのおしりにくっつけて送ります。
|*oauth_consumer_key|Twitterからもらったconsumer_key|
|*oauth_nonce|一意な値(にする必要があるが、とりあえず適当でもよいみたい)|
|*oauth_signature|認証するための暗号|
|*oauth_signature_method|認証方式(色々あるようだが、Twitterでは&amp;rdquo;HMAC-SHA1&amp;rdquo;固定)|
|*oauth_timestamp|今のタイムスタンプ(ミリ秒)|
|*oauth_version|バージョン(必須ではないが、付ける場合は&amp;rdquo;1.0&amp;rdquo;)|
consumer_key, nonce, signature_method, timestamp, versionの生成は難しくないのですが、問題はsignature。signature生成は大きく3つの流れを踏む事になります。</description>
    </item>
    
  </channel>
</rss>