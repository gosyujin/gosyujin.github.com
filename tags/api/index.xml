<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>API on kk_Atakaの日記</title>
    <link>/tags/api/</link>
    <description>Recent content in API on kk_Atakaの日記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sun, 21 Nov 2010 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/api/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SlideShareのAPIを叩いてスライドをDLするRubyスクリプトをHerokuにデプロイした</title>
      <link>/2012/05/21/1337605575/</link>
      <pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/05/21/1337605575/</guid>
      <description>[SlideShare][Heroku][Ruby][API]SlideShareのAPIを叩いてスライドをDLするRubyスクリプトをHerokuにデプロイした あらすじ slideshareを社内から閲覧する事を禁じられているので、ワンクッションおいてスライドのpptを落とせるようにしたい
参考サイト  http://www.slideshare.net/developers/documentation#get_slideshow:title  とりあえず公式サイトを抑えておけばいけそう。
流れ API申請  slideshare -&amp;gt; Developer &amp;amp; APIのページからApply for API keyに移動 ログイン or 新規アカウント作成 Name、E-Mail、How do you want to use the API?を入力し送信。頑張って英文書く。  I want to get slideshare&amp;#39;s slide from API.  送信されたメールに貼られているAPI KeyとShared Secretを控える  パラメータ  slideshare -&amp;gt; Documentationを見ながら必要なパラメータを調べる  |*api_key|さっきのAPI Key|
|*ts|タイムスタンプ[1]|
|*hash|さっきのShared Secretとこれから取得するtsでハッシュを作る[2]|
|*(username)|登録ID|
|*(password)|パスワード|
全然関係ないけど、Documentationのページ内にあるi.e.って単語を初めて見たのでググってみた。http://www.masahiko.info/life/archives/000799.html:title that is &amp;hellip; すなわちとかそういう意味らしい。e.g.で例えば、for example的な。
ソース ソースはこんな感じ。
require &amp;#39;openssl&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; url = &amp;#39;http://www.</description>
    </item>
    
    <item>
      <title>EvernoteのAPIをRubyから叩きたい</title>
      <link>/2011/12/27/1324911671/</link>
      <pubDate>Tue, 27 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/12/27/1324911671/</guid>
      <description>[Evernote][備忘録][Ruby][API]EvernoteのAPIをRubyから叩きたい はじめに この記事は[http://atnd.org/events/22021:title]の27日目の記事です。
26日目はid:tackunさんの[http://d.hatena.ne.jp/tackun/20111226/1324908770:title]でした。
28日目はr7kamuraさんのRubyでGPUを使おう - &amp;amp;#10008;&amp;amp;#9593;&amp;amp;#9697;&amp;amp;#9593;&amp;amp;#10008;です。
今日はターミナル(or コマンドプロンプト)経由でEvernoteのAPIを叩き、自分のノートブックを取得してみようとしてみます。ソースを書く前にAPIの申請からやっていきます。
APIの申請…の前に developer用サイトからAPI SDKを入手。
 http://www.evernote.com/about/developer/api/:title  [f:id:kk_Ataka:20111226235624j:image]
上記のリンクを叩くとzipがDLできるので、これを解凍しruby/lib以下のファイルを用意しておく。
APIの申請  http://www.evernote.com/about/developer/api/:title  同じページを下へスクロールしていくとRequest an API Keyという箇所があるので以下の項目を入力する。
|*Evernote username|Evernoteのユーザ名|
|*Your Name|氏名|
|*Your Email|メールアドレス|
|*Organization|組織や団体、だが、個人で使う場合は氏名でよい|
|*Web or Client|今回は自分で使う用なのでClient Keysを選択(既に持っているので下の画像ではWebを選択している)|
|*Application Details|どうやってAPIを使いたいか|
つたない英語でDetailsを書く。以前は審査に時間がかかったらしいが今はSUBMITすればすぐKeyが発行されるみたい。
[f:id:kk_Ataka:20111218113115j:image]
WebApplicationを選んだ場合。
[f:id:kk_Ataka:20111218113113j:image]
Clientを選んだ場合。
[f:id:kk_Ataka:20111218113114j:image]
これでConsumer KeyとConsumer Secretをもらえた。ただし、この状態では砂場(sandbox.evernote.com)でしか使えない。
上記画像のNext Steps 2.によると[https://sandbox.evernote.com/Registration.action:title]で砂場用アカウントを作成し、砂場で開発をしてくださいという事でいきなり本家(www.evernote.com)で動かせないようになっている。
Activate 今回のエントリではやらないが、本家で動かす時はActivateサイト(Next Steps 3.のlet us knowリンクから行ける)でActivateしてもらう必要がある。(ここは昔の事なので少し曖昧)
|*Email|メールアドレス|
|*API Consumer Key|登録時にもらったConsumer Key|
|*Additional Info|その他何かあれば？(何か書いたっけ…？)|
[f:id:kk_Ataka:20111218115757j:image]
ソース iitHubに。 https://github.com/gosyujin/evernote_for_ruby/blob/master/myEvernote.rb
ここから実際に取得していきます。
パス追加 プロジェクト内にあるライブラリ(さっき落としたAPI SDK)を読み込む。</description>
    </item>
    
    <item>
      <title>RubyではてなのWSSE認証をしてはてブにブクマをポストする</title>
      <link>/2011/03/08/1299588433/</link>
      <pubDate>Tue, 08 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/03/08/1299588433/</guid>
      <description>[Ruby][API]RubyではてなのWSSE認証をしてはてブにブクマをポストする ReadItLaterの続きをやろうと思ったのですが、GitHubにはてブスクリプトをコミットしたので先にまとめる。
結構前に作ったので、OAuthではなくWSSE認証を使っています。
手順  X-WSSEヘッダを作成する ブックマークするUrl・コメントを記述したxmlデータと、X-WSSEヘッダを含めたリクエストをhttp://b.hatena.ne.jp/atom/postへPOSTする  手順はこれだけ。次に詳細を…。
ヘッダを作成する 以下のデータを用意します
|*Username|はてなID|
|*Nonce|HTTPリクエスト毎に生成したセキュリティ・トークンをBASE64エンコードしたもの[1]|
|*Created|Nonce作成時のタイムスタンプをISO-8601表記で記述したもの|
|*PasswordDigest|「Nonce+Created+はてなのパスワード」をSHA1でダイジェスト化しBASE64エンコードしたもの|
これらのデータをX-WSSEヘッダに以下の形式で格納します。
UsernameToken Username=&amp;#34;USERNAME&amp;#34;, PasswordDigest=&amp;#34;PASSWORDDIGEST&amp;#34;, Nonce=&amp;#34;NONCE&amp;#34;, Created=&amp;#34;CREATED&amp;#34; POSTする ヘッダは完成したので、次にブックマークする情報を用意します。形式はxmlで以下のようなフォーマットで作成します。[2]
&amp;lt;entry xmlns=&amp;#34;http://purl.org/atom/ns#&amp;#34;&amp;gt; &amp;lt;title&amp;gt;dummy&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;related&amp;#34; type=&amp;#34;text/html&amp;#34; href=&amp;#34;ブックマークするURL&amp;#34; /&amp;gt; &amp;lt;summary type=&amp;#34;text/plain&amp;#34;&amp;gt;ブックマークコメント&amp;lt;/summary&amp;gt; &amp;lt;/entry&amp;gt; 作成されたヘッダとデータはこんな感じになります。
[f:id:kk_Ataka:20110308213639j:image]
最後に作成したヘッダとブックマークデータをhttp://b.hatena.ne.jp/atom/postへポストすると。
[f:id:kk_Ataka:20110308213640j:image]
おお。
正常に作成された場合は、ステータスコードは201が返ってくるようです。
ソース Gistは直接貼れるけどGitHubは貼れないのね…。ここにあります。[https://github.com/gosyujin/hatena:title]
require &amp;#39;rubygems&amp;#39; require &amp;#39;pit&amp;#39; require &amp;#39;time&amp;#39; require &amp;#39;digest/sha1&amp;#39; require &amp;#39;net/http&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;nkf&amp;#39; # wsse認証を行う def wsse(hatena_id, password) # 一意な値(仮実装) nonce = [Time.now.to_i.to_s].pack(&amp;#39;m&amp;#39;).gsub(/\n/, &amp;#39;&amp;#39;) # nonce作成時のタイムスタンプをISO-8601表記で記述したもの now = Time.</description>
    </item>
    
    <item>
      <title>Read it LaterをRubyで取得する</title>
      <link>/2011/03/02/1299062938/</link>
      <pubDate>Wed, 02 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/03/02/1299062938/</guid>
      <description>[Ruby][API]Read it LaterをRubyで取得する ブラウザからログインせずともRILを見たい！　追加したい！　ということで。
前準備  はじめにapikeyを取得するためにhttp://readitlaterlist.com/api/signup/にアクセスします。[1] 必須項目(AppNameとContact Email)を記入し、Generate API Keyします。 取得したapikeyを取っておきます。  [f:id:kk_Ataka:20110302190610p:image]
 APIの概要はhttp://readitlaterlist.com/api/docs/に載っているので、基本的にはこれを見ながらできる…はず。  記事をGetする 以下のパラメータを生成し、URLのおしりに?AAA=BBB&amp;amp;CCC=DDD&amp;hellip;形式でくっつけてhttps://readitlaterlist.com/v2/getに送ります。[2]パラメータは他にもあるけど、とりあえずこれだけあれば取得はできます。
|*apikey(必須)|今生成したapikey|
|*username(必須)|Read It Laterのアカウント|
|*password(必須)|パスワード|
|*format|レスポンスのフォーマット。jsonかxmlが選択できる。デフォルトはjson|
パスワードが丸見えなのでショルダーハックとかされるとアレですが…。
ソースコード ここまでをRubyで書いてみました。jsonの解析はTwitterから取得したツイートを解析したときと同じようにsimplejsonparserを使用させていただきました。
require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; # http://rubyforge.org/snippet/detail.php?type=snippet&amp;amp;id=148 require &amp;#39;simplejsonparser&amp;#39; require &amp;#39;pp&amp;#39; # RIL取得用のURL url = &amp;#34;https://readitlaterlist.com/v2/get&amp;#34; # アカウント名とパスワード username = &amp;#34;kk_Ataka&amp;#34; password = PASSWORD # apikey apikey = APIKEY # format json or xml format = &amp;#34;json&amp;#34; # パラメータ作成 param = &amp;#34;username=#{username}&amp;amp;password=#{password}&amp;amp;apikey=#{apikey}&amp;amp;format=#{format}&amp;#34; # GETする uri = URI.</description>
    </item>
    
    <item>
      <title>RubyでTwitterにツイートをキメてみる</title>
      <link>/2011/01/23/1295789180/</link>
      <pubDate>Sun, 23 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/01/23/1295789180/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterにツイートをキメてみる 前回までのあらすじ  http://d.hatena.ne.jp/kk_Ataka/20101121/1290271210:title http://d.hatena.ne.jp/kk_Ataka/20101130/1291125511:title http://d.hatena.ne.jp/kk_Ataka/20101207/1291733295:title  ターミナルからOAuth認証をキメて、タイムラインを見られるようになりました。最後にターミナルからツイートが出来れば一応Twitterの見る・書くがライブラリ無しでできたことになります。
ツイートする方法  signatureを作成する。必要な値は以下のとおり。  oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version status New!   statusっていうのがツイートの本文ですね。signature作成するのにエスケープします。作成後のheaderはこんな感じ。[1]statusには「確認確認」って入ってます。
{ &amp;#34;oauth_nonce&amp;#34;=&amp;gt;&amp;#34;3c8293f9c5a0295148d428a26edb9f46&amp;#34;, &amp;#34;oauth_timestamp&amp;#34;=&amp;gt;&amp;#34;1295784908&amp;#34;, &amp;#34;oauth_signature_method&amp;#34;=&amp;gt;&amp;#34;HMAC-SHA1&amp;#34;, &amp;#34;oauth_consumer_key&amp;#34;=&amp;gt;&amp;#34;XXXXXXXXXXXXXXXXXXXXXX&amp;#34;, &amp;#34;oauth_token&amp;#34;=&amp;gt;&amp;#34;99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY&amp;#34;, &amp;#34;oauth_signature&amp;#34;=&amp;gt;&amp;#34;UKt1BmJ+UWNWrSmBuAyJ40iiCNY=&amp;#34;, &amp;#34;status&amp;#34;=&amp;gt;&amp;#34;%E7%A2%BA%E8%AA%8D%E7%A2%BA%E8%AA%8D&amp;#34;, &amp;#34;oauth_version&amp;#34;=&amp;gt;&amp;#34;1.0&amp;#34; } signature作成後  signatureを作成したら、headerからstatusを消します 残ったheaderをアルファベット順に並べ、xxx=yyy,vvv=zzz……の形で連結します。連結後はこんな感じ  oauth_consumer_key=XXXXXXXXXXXXXXXXXXXXXX,oauth_nonce=341d852d61cdc3c22e3e847b0ab69d20,oauth_signature=MR5WEJ1qHuE49ozgRYduNJ%2BBiCs%3D,oauth_signature_method=HMAC-SHA1,oauth_timestamp=1295785315,oauth_token=99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY,oauth_version=1.0  連結した上記の値をAuthorizationヘッダに入れる。入れた後はこんな感じ。  &amp;#34;Authorization&amp;#34;=&amp;gt;&amp;#34;OAuth oauth_consumer_key=XXXXXXXXXXXXXXXXXXXXXX,oauth_nonce=341d852d61cdc3c22e3e847b0ab69d20,oauth_signature=MR5WEJ1qHuE49ozgRYduNJ%2BBiCs%3D,oauth_signature_method=HMAC-SHA1,oauth_timestamp=1295785315,oauth_token=99999999-YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY,oauth_version=1.0&amp;#34;  Authorizationヘッダを作成したらhttp://api.twitter.com/1/statuses/home_timeline.jsonへPOST。また、ツイート本文を「status=本文」の形でくっつける  結果 以上で、Twitterにツイートが完了しました！　おっぱいきたーー
[f:id:kk_Ataka:20110123215838j:image]
ソース ソースはこんな感じです。
# -*- encoding: UTF-8 -*- require &amp;#39;openssl&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; require &amp;#39;nkf&amp;#39; require &amp;#39;time&amp;#39; # 署名 def sigunature(method, consumer_secret, oauth_token_secret, url, oauth_header=nil) # sigunature_keyの作成 # リクエストトークン時は&amp;#34;CONSUMER_SECRET&amp;amp;&amp;#34;(アンドが入っている) # アクセストークン時は&amp;#34;CONSUMER_SECRET&amp;amp;OAUTH_TOKEN_SECRET&amp;#34;として使用 sigunature_key = consumer_secret + &amp;#34;&amp;amp;&amp;#34; if !</description>
    </item>
    
    <item>
      <title>RubyでTwitterのタイムラインを取得してみる</title>
      <link>/2010/12/07/1291733295/</link>
      <pubDate>Tue, 07 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/12/07/1291733295/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのタイムラインを取得してみる 前回までのあらすじ  http://d.hatena.ne.jp/kk_Ataka/20101121/1290271210:title http://d.hatena.ne.jp/kk_Ataka/20101130/1291125511:title  前回までで、なんとかOAuth認証を突破する事ができました。目標は達成できたっちゃあできたんですが……せっかくなので、取得したアクセストークンを使ってTwitterからタイムラインを取得してみます！
タイムラインの取得方法  signatureを作成する 以下のパラメータをアルファベット順にxxx=yyy&amp;amp;vvv=zzz……の形で連結した値を[http://api.twitter.com/1/statuses/home_timeline.json]のおしりにくっつけてGET or POST  oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version   取得はこれで完了。
signatureの作成方法は今までと同じで、
 認証用の値を生成する(以下の3つの値を&amp;amp;で連結する)  &amp;ldquo;GET&amp;rdquo; &amp;ldquo;http://api.twitter.com/1/statuses/home_timeline.json&amp;ldquo;をエスケープしたもの oauth_signature以外のパラメータ[1]をアルファベット順に並べてxxx=yyy&amp;amp;vvv=zzz……の形で連結した値をエスケープしたもの  署名キーを生成する  &amp;ldquo;consumer_secret&amp;amp;oauth_token_secret&amp;rdquo;  キーを元に値をHMAC-SHA1方式で暗号化した値をbase64形式でエンコードする  です。OAuth認証して獲得したアクセストークン、oauth_tokenとoauth_token_secretを随所で使います。そして作成したsignatureと他のパラメータを[http://api.twitter.com/1/statuses/home_timeline.json]のおしりにくっつけて(今回は)GETリクエスト。
戻ってきたタイムライン タイムラインらしきものはjsonという形式のデータで戻って来ます。home_timeline.jsonのjson部分をxmlとかrssに変えるとxml形式のタイムライン、rss形式のタイムラインが返ってくるようですが今回はこのjsonを何とかしてみます。
jsonの詳細は後にググるとして、一人当たりの情報はこんな感じ。[2]
.......},{ \&amp;#34;coordinates\&amp;#34;:null, \&amp;#34;created_at\&amp;#34;:\&amp;#34;Tue Dec 07 13:50:49 +0000 2010\&amp;#34;, . (略) . \&amp;#34;in_reply_to_screen_name\&amp;#34;:null, \&amp;#34;in_reply_to_status_id_str\&amp;#34;:null, \&amp;#34;id_str\&amp;#34;:\&amp;#34;99999999999999999\&amp;#34;, \&amp;#34;contributors\&amp;#34;:null, \&amp;#34;retweet_count\&amp;#34;:null, \&amp;#34;in_reply_to_user_id\&amp;#34;:null, \&amp;#34;in_reply_to_user_id_str\&amp;#34;:null, \&amp;#34;user\&amp;#34;:{ . (略) . \&amp;#34;screen_name\&amp;#34;:\&amp;#34;kk_Ataka\&amp;#34;, \&amp;#34;profile_sidebar_border_color\&amp;#34;:\&amp;#34;C0DEED\&amp;#34;, \&amp;#34;follow_request_sent\&amp;#34;:false, \&amp;#34;location\&amp;#34;:\&amp;#34;Kawasaki, Kanagawa, Japan\&amp;#34;, .</description>
    </item>
    
    <item>
      <title>RubyでTwitterのOAuth認証をしてみる その2</title>
      <link>/2010/11/30/1291125511/</link>
      <pubDate>Tue, 30 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/11/30/1291125511/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのOAuth認証をしてみる その2 前回のエントリ では、リクエストトークンまで発行してもらえました。だもんで今回は前回に続いてアクセストークンを発行してもらいます。アクセストークン発行の流れとしては、
 今もらったリクエストトークンを付加して http://twitter.com/oauth/authorize へアクセスする 画面に表示されるPINコード(oauth_verifier)を控える リクエストトークンとPINコードをを付加して http://twitter.com/oauth/access_token へアクセスする  行きます。
PINコードを発行してもらう リクエストトークンを発行してもらうと、
oauth_token=XXXXXXXXXX&amp;amp;oauth_token_secret=YYYYYYYYYYYYYYYYYYYYYYYYYYYY&amp;amp;oauth_callback_confirmed=true という文字列がbodyに埋まってきたはず。[1]
この中から oauth_tokenを抜き出し、 http://twitter.com/oauth/authorize にパラメータとしてくっつけます。こんな感じ。
http://twitter.com/oauth/authorize?oauth_token=XXXXXXXXXX
アドレスが正しければ、以下のような画面が出るはず。[2]アプリケーションからのアクセスを許可しますか？　と尋ねられるので許可するを選択。
[f:id:kk_Ataka:20101130220734j:image]
許可すると、PINコードが画面に表示されるのでこれを控えておく。
[f:id:kk_Ataka:20101130220731j:image]
再度signatureを作成する このPINコードを&amp;rdquo;oauth_verify&amp;rdquo;として。先ほどURLに貼っつけたoauth_tokenを&amp;rdquo;oauth_token&amp;rdquo;としてパラメータとして持たせます。
そして、ここでもう一度signatureを作成を作成します。注意点としては、
 今まで使っていたoauth_signatureは一旦消して、以下のパラメータで新たにつくり直す  oauth_consumer_key oauth_nonce oauth_signature_method oauth_timestamp oauth_version oauth_token New! oauth_verifier New!  URLは&amp;rdquo;http://twitter.com/oauth/access_token&amp;rdquo;をエスケープしたもの 暗号化用のキーは&amp;rdquo;consumer_secret&amp;amp;oauth_token_secret&amp;rdquo;[3]  この3点でしょうか。
signatureが作成できたら、前回と同様にアルファベット順に並べて連結し、URLのおしりにくっつけます。URLはこんな感じになります。
[f:id:kk_Ataka:20101130223243j:image]
成功したら、oauth_token, oauth_token_secret, user_id, screen_nameが返ってきます。これ俺や！！
[f:id:kk_Ataka:20101130220728j:image]
ここで返してもらったoauth_tokenとoauth_token_secretは本物なので大切にとっておく！　というわけで、次は自分のTimelineを取得します！
ソースはこんな感じ。
require &amp;#39;openssl&amp;#39; require &amp;#39;uri&amp;#39; require &amp;#39;net/http&amp;#39; # signature作成 def signature(method, consumer_secret, oauth_token_secret, url, oauth_header) # signature_keyの作成 # リクエストトークン時は&amp;#34;CONSUMER_SECRET&amp;amp;&amp;#34;(アンドが入っている) # アクセストークン時は&amp;#34;CONSUMER_SECRET&amp;amp;OAUTH_TOKEN_SECRET&amp;#34;として使用 signature_key = consumer_secret + &amp;#34;&amp;amp;&amp;#34; if !</description>
    </item>
    
    <item>
      <title>RubyでTwitterのOAuth認証をしてみる</title>
      <link>/2010/11/21/1290271210/</link>
      <pubDate>Sun, 21 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/11/21/1290271210/</guid>
      <description>[Ruby][Twitter][API]RubyでTwitterのOAuth認証をしてみる 随分前にTwitterがベーシック認証からOAuth認証に切り替えたという事で。Java+Wicket+AppEngineでベーシック認証を駆使して作っていたTwitterサイトが見れなくなったもんで切り替えました。(http://gihyo.jp/dev/feature/01/wicket:title を見つつ)
一応出来たんですが、結局のところOAuthがどうなってるのかよくわからなかった……ので、ちょっと一から書いてみようと。
id:Yoshiori さんのhttp://d.hatena.ne.jp/Yoshiori/20100929/1285727199:title と、 id:yuroyoro さんの[http://d.hatena.ne.jp/yuroyoro/20100506/1273137673:title]がとっても詳しかったので、参考にしました。
大きな流れとしては、
 consumer_keyとconsumer_secretを発行してもらう リクエストトークンを発行してもらう アクセストークンを発行してもらう  の3項目。今回はリクエストトークンを発行してもらうところまでやります。
準備 Twitterにアプリを登録し、consumer_keyとconsumer_secretを発行してもらう  Twitterにログイン &amp;gt; 設定 &amp;gt; 連携アプリ を選択  [f:id:kk_Ataka:20101120225746p:image]
 開発者の方へ &amp;gt; こちら を選択  [f:id:kk_Ataka:20101120230042p:image]
 ページ下部の新しいアプリケーションを追加 を選択  [f:id:kk_Ataka:20101120230314p:image]
後で編集もできるのでとりあえず入力しておく。下記の2項目はとりあえず
 - アプリケーションの種類: クライアントアプリケーション  標準のアクセスタイプ: Read &amp;amp; Write   にしておく。
 登録したら、consumer_keyとconsumer_secretをもらえるので控えておく  [f:id:kk_Ataka:20101120232314p:image]
フォローをリクエストしました。のURL、Access token URL、Authorize URLは認証時に使うのでこれも控えておく。
リクエストトークンを発行してもらう こっからRuby。以下のパラメータを生成してhttp://twitter.com/oauth/request_tokenに送ります。POSTでもGETでもよいみたいなので、今回はGETを使ってURLのおしりにくっつけて送ります。
|*oauth_consumer_key|Twitterからもらったconsumer_key|
|*oauth_nonce|一意な値(にする必要があるが、とりあえず適当でもよいみたい)|
|*oauth_signature|認証するための暗号|
|*oauth_signature_method|認証方式(色々あるようだが、Twitterでは&amp;rdquo;HMAC-SHA1&amp;rdquo;固定)|
|*oauth_timestamp|今のタイムスタンプ(ミリ秒)|
|*oauth_version|バージョン(必須ではないが、付ける場合は&amp;rdquo;1.0&amp;rdquo;)|
consumer_key, nonce, signature_method, timestamp, versionの生成は難しくないのですが、問題はsignature。signature生成は大きく3つの流れを踏む事になります。</description>
    </item>
    
  </channel>
</rss>